{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"RISC-V Steel Documentation","text":"<p>Welcome to RISC-V Steel documentation page.</p> <p> Getting Started Guide  GitHub</p>"},{"location":"#about-risc-v-steel","title":"About RISC-V Steel","text":"<p>RISC-V Steel is a free collection of hardware modules written in Verilog intended for use in FPGAs and embedded systems. It features a 32-bit RISC-V processor core, UART, GPIO and SPI interfaces, and timer and memory modules. All modules are integrated into a tunable microcontroller design that can be easily ported to any FPGA in just a few steps.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>32-bit RISC-V processor core (RV32I + Zicsr + Machine mode)</li> <li>UART, GPIO and SPI interfaces</li> <li>Timer and memory modules</li> <li>Support for real-time operating systems like FreeRTOS</li> <li>LibSteel library, which provides an API to control RISC-V Steel</li> </ul>"},{"location":"#license","title":"License","text":"<p>RISC-V Steel is distributed under the MIT License.</p> <p> </p>"},{"location":"core/","title":"RISC-V Steel Processor Core","text":"Documentation"},{"location":"core/#introduction","title":"Introduction","text":"<p>RISC-V Steel Processor Core is a 32-bit processor core implementing the RV32I instruction set, the Zicsr extension and the Machine-mode privileged architecture of RISC-V.</p> <p>RISC-V Steel Processor Core is a single-issue, in-order, unpipelined processor core.</p> <p>RISC-V Steel Processor Core can run real-time operating systems and bare-metal embedded software. It is designed to work as a processing unit in a wide variety of embedded applications.</p>"},{"location":"core/#source-files","title":"Source files","text":"<p>RISC-V Steel Processor Core has a single source file, <code>rvsteel_core.v</code>, saved in the <code>hardware/core/</code> folder.</p>"},{"location":"core/#io-signals","title":"I/O signals","text":"<p>Table 1 - RISC-V Steel Processor Core input and output signals</p> Global signals Signal name Direction Size Description clock Input 1 bit Clock input. reset Input 1 bit Reset signal (active-high). halt Input 1 bit Halt signal (active-high). I/O interface Signal name Direction Size Description rw_address Output 32 bits Address of the read/write operation. read_data Input 32 bits Data read. read_request Output 1 bit Read request. read_response Input 1 bit Response to the read request. write_data Output 32 bits Data to be written. write_strobe Output 4 bits A signal indicating which byte lanes of write_data holds the data to be written. write_request Output 1 bit Write request. write_response Input 1 bit Response to the write request. Interrupt handling Signal name Direction Size Description irq_fast Input 16 bit 16 fast interrupt request lines for peripheral devices. Priority increases in ascending order (line 0 has the highest priority, line 15 the lowest). irq_fast_response Output 16 bit 16 response lines for interrupt requests. irq_external Input 1 bit External interrupt request. irq_external_response Output 1 bit Response to the external interrupt request. irq_timer Input 1 bit Timer interrupt request. irq_timer_response Output 1 bit Response to the timer interrupt request. irq_software Input 1 bit Software interrupt request. irq_software_response Output 1 bit Response to the software interrupt request. Real time clock Signal name Direction Size Description real_time_clock Input 64 bits Real time clock, used to update the <code>mtime</code> CSR."},{"location":"core/#configuration","title":"Configuration","text":"<p>The only configuration parameter of RISC-V Steel Processor Core is the boot address (<code>BOOT_ADDRESS</code>). In case you leave this parameter blank the boot address is automatically set to <code>32'h00000000</code>.</p>"},{"location":"core/#instantiation-template","title":"Instantiation template","text":"<p>An instantiation template for RISC-V Steel Processor Core top module is provided below.</p> <pre><code>rvsteel_core #(\n\n  // Address of the first instruction to be fetched and executed\n\n  .BOOT_ADDRESS           ()  // defaults to 32'h00000000 if left blank\n\n) rvsteel_core_instance (\n\n  // Global signals\n\n  .clock                  (),\n  .reset                  (), // reset is active-high\n  .halt                   (), // halt is active-high\n\n  // IO interface\n\n  .rw_address             (),\n  .read_data              (),\n  .read_request           (),\n  .read_response          (),\n  .write_data             (),\n  .write_strobe           (),\n  .write_request          (),\n  .write_response         (),\n\n  // Interrupt signals\n\n  .irq_fast               (), // hardwire to 16'b0 if unused\n  .irq_fast_response      (), // leave blank if unused\n  .irq_external           (), // hardwire to 1'b0 if unused\n  .irq_external_response  (), // leave blank if unused\n  .irq_timer              (), // hardwire to 1'b0 if unused\n  .irq_timer_response     (), // leave blank if unused\n  .irq_software           (), // hardwire to 1'b0 if unused\n  .irq_software_response  (), // leave blank if unused\n\n  // Real Time Clock\n\n  .real_time_clock        ()  // hardwire to 64'b0 if unused\n\n);\n</code></pre>"},{"location":"core/#io-operations","title":"I/O operations","text":"<p>RISC-V Steel Processor Core communicates with external devices (memory and peripherals) through its I/O interface signals (see Table 1). In each clock cycle the processor either requests to read or write data. It never requests both operations in the same clock cycle.</p> <p>As in all RISC-V systems, the processor address space is shared among all devices, both memory and peripherals. Each device is mapped to a region in the address space. Communication with a device takes place by reading and writing data at addresses assigned exclusively to that device.</p> <p>The two sections below explain how read and write operations are requested by the processor core and the expected response to these requests.</p>"},{"location":"core/#read-operation","title":"Read operation","text":"<p>The processor core drives the I/O interface signals as follows on a read request:</p> <ul> <li> <p>the address is placed in the rw_address bus.</p> </li> <li> <p>the read_request signal is driven to logic <code>HIGH</code>.</p> </li> <li> <p>the rw_address and read_request signals remain stable until read_response is driven to logic <code>HIGH</code> by the external device.</p> </li> </ul> <p>The response to the read request from the external device must observe these rules:</p> <ul> <li> <p>The read data must be placed in the read_data bus.</p> </li> <li> <p>the read_response signal must be driven to logic <code>HIGH</code> only when read_data holds valid data, and it must be held <code>HIGH</code> for only one clock cycle.</p> </li> <li> <p>The read response must never be given in the same clock cycle that read_request was driven <code>HIGH</code>.</p> </li> </ul> <p>The timing diagram below contains examples of valid read operations:</p> <p> </p> Figure 1 - Read operation timing diagram"},{"location":"core/#write-operation","title":"Write operation","text":"<p>The processor core drives the I/O interface signals as follows on a write request:</p> <ul> <li> <p>the address is placed in the rw_address bus.</p> </li> <li> <p>the write_request signal is driven to logic <code>HIGH</code>.</p> </li> <li> <p>the data to be written is placed in the write_data bus.</p> </li> <li> <p>the write_strobe signal will indicate which byte lanes of write_data must be written.</p> <p>For example, if this signal holds <code>4'b0001</code>, only the least significant byte must be written. The upper 24 bits of write_data must be ignored.</p> </li> <li> <p>all signals above remain stable until write_response is driven to logic <code>HIGH</code> by the external device.</p> </li> </ul> <p>The response to the write request from the external device must observe these rules:</p> <ul> <li> <p>the write_response signal must be driven to logic <code>HIGH</code> only if the write operation succeeded, and it must be held <code>HIGH</code> for only one clock cycle.</p> </li> <li> <p>The write response must never be given in the same clock cycle that write_request was driven <code>HIGH</code>.</p> </li> </ul> <p>The timing diagram below contains examples of valid write operations:</p> <p> </p> Figure 2 - Write operation timing diagram"},{"location":"core/#exceptions-interrupts-and-traps","title":"Exceptions, interrupts and traps","text":""},{"location":"core/#overview","title":"Overview","text":"<p>In the RISC-V architeture, a trap refers to the transfer of control caused by either an exception or interrupt. A trap is said to be taken when an exception or interrupt change the program normal execution order by writing to the program counter the start address of a trap handler software routine, as configured in the mtvec CSR.</p> <p>An exception always causes a trap to be taken. An interrupt causes a trap to be taken only if:</p> <ul> <li> <p>the global interrupt enable bit is set (field mie in the mstatus CSR), and</p> </li> <li> <p>the corresponding interrupt type is enabled (fields meie, mtie and msie in the mie CSR).</p> </li> </ul> <p>The exceptions and interrupts implemented in RISC-V Steel Processor Core are listed in the table below. They are listed in descending priority order, that is, the topmost has the highest priority.</p> <p>Table 2 - RISC-V Steel Processor Core implemented exceptions and interrupts</p> Priority Type <code>mstatus[31]</code> <code>mstatus[30:0]</code> Description highest Exception 0 2 Illegal instruction Exception 0 0 Misaligned instruction address Exception 0 11 Environment call from M-mode Exception 0 3 Breakpoint call from M-mode Exception 0 6 Misaligned store address Exception 0 4 Misaligned load address Interrupt 1 16 Fast interrupt #0 Interrupt 1 17 Fast interrupt #1 Interrupt ... ... ... Interrupt 1 32 Fast interrupt #15 Interrupt 1 11 External interrupt Interrupt 1 3 Software interrupt lowest Interrupt 1 7 Timer interrupt"},{"location":"core/#interrupt-request-handshake","title":"Interrupt request handshake","text":"<p>A device can request an interrupt by driving the corresponding irq_* signal to logic <code>HIGH</code> and holding it <code>HIGH</code> until the request is accepted. The processor accepts the request by driving the irq_*_response signal to logic <code>HIGH</code> for one clock cycle. The requesting device can drive the irq_* signal to logic <code>LOW</code> in the clock cycle that follows the response, or keep it <code>HIGH</code> to make a new request.</p> <p>RISC-V Steel Processor Core provides 16 fast interrupt request lines and one additional line for each of the standard RISC-V interrupt types: external, timer, and software.</p> <p>The timing diagram below is an example of a valid interrupt request:</p> <p> </p> Figure 3 - Interrupt request timing diagram"},{"location":"core/#trap-handling","title":"Trap handling","text":"<p>RISC-V Steel Processor Core proceeds as follows when a trap is taken:</p> <ul> <li> <p>the execution of the current instruction is aborted.</p> </li> <li> <p>the memory address of the aborted instruction is saved in the mepc CSR.</p> </li> <li> <p>the program counter is set to the value of the mtvec CSR.</p> </li> <li> <p>the mcause CSR is set to a value encoding the type of the interrupt (see Table 2 above).</p> </li> <li> <p>the current value of the global interrupt enable bit mstatus.mie is saved in mstatus.mpie (prior interrupt enable bit).</p> </li> <li> <p>mstatus.mie is set to logic <code>LOW</code>, disabling new interrupts in case they were enabled.</p> </li> <li> <p>if the trap was caused by an interrupt, the corresponding response signal (irq_*_response) is set to logic <code>HIGH</code> for one clock cycle.</p> </li> </ul> <p>The mtvec CSR is set by software to the address of a trap handler routine, so the core branches from normal execution and starts the execution of the trap handler.</p> <p>The mret instruction is used by software to return from the trap handler. When this instruction is executed the core proceeds as follows:</p> <ul> <li> <p>the program counter is set to the value of the mepc CSR.</p> </li> <li> <p>the global interrupt enable bit mstatus.mie receives the value saved in the mstatus.mpie bit.</p> </li> <li> <p>the prior interrupt enable bit mstatus.mpie is set to logic <code>LOW</code>.</p> </li> </ul> <p>The value in the mepc register holds the address of the instruction aborted when the trap was taken, so normal execution is resumed.</p>"},{"location":"core/#real-time-clock","title":"Real time clock","text":"<p>Systems that require a real time clock can connect the time CSR to an external clock device through the real_time_clock bus. By doing so, wall clock time can be obtained by reading the time CSR with the csrrw instruction.</p> <p>Systems that do not need a real time clock can hardwire this signal to <code>64'b0</code>, which causes reading the time CSR to return zero. In this case time lapses can still be measured by reading the cycle counter mcycle, as long as the clock signal is connected to a stable oscillating signal.</p> <p> </p>"},{"location":"gettingstarted/","title":"Getting Started Guide","text":"<p>RISC-V Steel is a free collection of hardware modules written in Verilog intended for use in FPGAs and embedded systems. It features a 32-bit RISC-V processor core, UART, GPIO and SPI interfaces, and timer and memory modules. All modules are integrated into a tunable microcontroller design that can be easily ported to any FPGA in just a few steps.</p> <p>This getting started guide will show you how to use RISC-V Steel to create a Hello World system for your FPGA. This example system is a simple embedded application that sends a Hello World! message through the UART interface of RISC-V Steel. You will be able to see this message on your computer with the help of a serial terminal emulator (PySerial) after programming the FPGA.</p> <p>After you finish this guide you will have a basic environment that you can use to create larger projects.</p>"},{"location":"gettingstarted/#1-download-risc-v-steel","title":"1. Download RISC-V Steel","text":"<p>First of all, download RISC-V Steel by running:</p> <pre><code>git clone https://github.com/riscv-steel/riscv-steel\n</code></pre>"},{"location":"gettingstarted/#2-download-and-install-the-risc-v-gnu-toolchain","title":"2. Download and install the RISC-V GNU Toolchain","text":"<p>The RISC-V GNU Toolchain is a set of compilers and software development tools for the RISC-V architecture. You need it to compile the C program written for the Hello World system.</p> <p>2.1. Get the RISC-V GNU Toolchain</p> <pre><code>git clone https://github.com/riscv/riscv-gnu-toolchain\n</code></pre> <p>2.2. Install dependencies (choose your OS)</p> UbuntuFedora/CentOS/RHEL OSArch LinuxOS X <pre><code>sudo apt-get install autoconf automake autotools-dev curl python3 python3-pip libmpc-dev libmpfr-dev libgmp-dev gawk build-essential bison flex texinfo gperf libtool patchutils bc zlib1g-dev libexpat-dev ninja-build git cmake libglib2.0-dev libslirp-dev\n</code></pre> <pre><code>sudo yum install autoconf automake python3 libmpc-devel mpfr-devel gmp-devel gawk  bison flex texinfo patchutils gcc gcc-c++ zlib-devel expat-devel libslirp-devel\n</code></pre> <pre><code>sudo pacman -Syyu autoconf automake curl python3 libmpc mpfr gmp gawk base-devel bison flex texinfo gperf libtool patchutils bc zlib expat libslirp\n</code></pre> <pre><code>brew install python3 gawk gnu-sed gmp mpfr libmpc isl zlib expat texinfo flock libslirp\n</code></pre> <p>2.3. Configure the toolchain for RISC-V Steel and install it</p> <p><pre><code>cd riscv-gnu-toolchain\n./configure --prefix=/opt/riscv --with-arch=rv32izicsr --with-abi=ilp32\nmake\n</code></pre> Tip: Change the <code>--prefix</code> argument to install the toolchain in a different folder.</p>"},{"location":"gettingstarted/#3-build-the-hello-world-example","title":"3. Build the Hello World example","text":"<p>The software project for the Hello World system is saved in <code>examples/hello_world/software/</code>. This folder contains:</p> <ul> <li>a Hello World example program, <code>main.c</code></li> <li>a linker script for RISC-V Steel</li> <li>a Makefile to automate building tasks</li> <li>a <code>CMakeLists.txt</code> file with build instructions for CMake</li> <li>LibSteel library, which provides an API to control RISC-V Steel</li> </ul> <p>The Hello World program in <code>main.c</code> is perhaps the simplest application you can build with RISC-V Steel. Its source code is reproduced below.</p> <pre><code>#include \"libsteel.h\"\n\nvoid main(void) {\n  uart_write_string(RVSTEEL_UART, \"Hello World from RISC-V Steel!\");\n}\n</code></pre> <p>As you can see, this program calls <code>uart_write_string</code> from <code>libsteel.h</code> to send a Hello World! message to the UART controller.</p> <p>To build the project, run:</p> <pre><code>cd riscv-steel/examples/hello_world/software/\nmake release PREFIX=/opt/riscv\n</code></pre> <p>The build output will be saved to <code>build/</code> and contain a file named <code>hello_world.hex</code>. You will use this file in the next step to initialize the memory of RISC-V Steel.</p>"},{"location":"gettingstarted/#4-port-risc-v-steel-to-your-fpga","title":"4. Port RISC-V Steel to your FPGA","text":"<p>4.1. Create a new hardware module <code>hello_world</code> with an instance of RISC-V Steel</p> <p>Using your preferred text editor, create a new Verilog file named <code>hello_world.v</code> and add the code below.</p> <p>Don't forget to change the instance parameters as instructed in the comments!</p> <pre><code>module hello_world (\n\n  input wire clock,\n  input wire reset,\n  output wire uart_tx\n\n  );\n\n  reg reset_debounced;\n  always @(posedge clock) reset_debounced &lt;= reset;\n\n  rvsteel_mcu #(\n\n    // Change to the frequency (in Hertz) of your FPGA board clock source\n    .CLOCK_FREQUENCY          (50000000                   ),\n    // Change to the absolute path to the .hex file generated in the previous step\n    .MEMORY_INIT_FILE         (\"/path/to/hello_world.hex\" ),\n\n    // The parameters below don't need to be changed for this example\n    .MEMORY_SIZE              (8192                       ),\n    .UART_BAUD_RATE           (9600                       ),\n    .BOOT_ADDRESS             (32'h00000000               ),\n    .GPIO_WIDTH               (1                          ),\n    .SPI_NUM_CHIP_SELECT      (1                          ))\n\n    rvsteel_mcu_instance      (\n\n    .clock                    (clock                      ),\n    .reset                    (reset_debounced            ),\n    .halt                     (1'b0                       ),\n    .uart_rx                  (/* unused */               ),\n    .uart_tx                  (uart_tx                    ),\n    .gpio_input               (1'b0                       ),\n    .gpio_oe                  (/* unused */               ),\n    .gpio_output              (/* unused */               ),\n    .sclk                     (/* unused */               ),\n    .pico                     (/* unused */               ),\n    .poci                     (1'b0                       ),\n    .cs                       (/* unused */               ));\n\nendmodule\n</code></pre> <p>4.2. Implement the new <code>hello_world</code> design on your FPGA</p> <p>The specific steps to implement the <code>hello_world</code> design you created above vary depending on the vendor and model of your FPGA. However, they can be broken down into the following general steps:</p> <ul> <li>Open the EDA software for your FPGA (e.g. AMD Vivado, Intel Quartus, Lattice iCEcube)</li> <li>Create a new project named <code>hello_world</code>. Add the following files to the project:<ul> <li>The Verilog file you just created, <code>hello_world.v</code></li> <li>All Verilog files saved in <code>riscv-steel/hardware/mcu/</code>. You don't need to add the <code>tests</code> folder and its contents.</li> </ul> </li> <li>Create a design constraints file<ul> <li>Assign the <code>clock</code> pin of <code>hello_world.v</code> to a clock source</li> <li>Assign the <code>reset</code> pin of <code>hello_world.v</code> to a push-button or switch</li> <li>Assign the <code>uart_tx</code> pin to the receiver pin (rx) of the UART of your FPGA board</li> </ul> </li> <li>Run synthesis, place and route, and any other intermediate step needed to generate a bitstream for the FPGA</li> <li>Upload the bitstream to your FPGA </li> </ul>"},{"location":"gettingstarted/#5-run-the-application","title":"5. Run the application","text":"<p>The Hello World program starts running as soon as you finish uploading the bitstream.</p> <p>To receive the Hello World! message on your computer you need a serial terminal emulator like PySerial, which we show how to install below:</p> <ul> <li>Connect the UART of your FPGA board to your computer (if not already connected)</li> <li>Open a serial terminal emulator:<ul> <li>To install PySerial, run <code>python3 -m pip install pyserial</code></li> <li>To open a PySerial terminal, run <code>python3 -m serial.tools.miniterm</code></li> <li>PySerial will show the available serial ports, one of which the UART of your FPGA board. Choose it to connect.</li> <li>If you are not using PySerial, adjust the UART configuration to 9600 bauds/s, 8 data bits, no parity, no control and no stop bit</li> </ul> </li> <li>Press the reset button</li> <li>You should now see the Hello World message!</li> </ul> <p> </p>"},{"location":"mcu/","title":"RISC-V Steel Microcontroller Unit","text":"Documentation"},{"location":"mcu/#architectural-overview","title":"Architectural overview","text":"<p>RISC-V Steel Microcontroller Unit is the top hardware module of RISC-V Steel. It contains an instance of RISC-V Steel Processor Core, the main component of its design, and an instance of RISC-V Steel UART, GPIO, SPI, timer and memory modules.</p> <p>The processor core is integrated to the memory, timer, UART, GPIO and SPI modules via a shared bus that coordinates memory accesses.</p> <p></p>"},{"location":"mcu/#source-files","title":"Source files","text":"<p>The Verilog source files of RISC-V Steel Microcontroller Unit are saved in the <code>hardware/mcu/</code> folder of RISC-V Steel repository.</p>"},{"location":"mcu/#instantiation-template","title":"Instantiation template","text":"<pre><code>rvsteel_mcu #(\n\n  // See Configuration paramaters below for more information.\n\n  .CLOCK_FREQUENCY      (50000000       ),\n  .UART_BAUD_RATE       (9600           ),\n  .MEMORY_SIZE          (8192           ),\n  .MEMORY_INIT_FILE     (\"mem_init.hex\" ),\n  .BOOT_ADDRESS         (32'h00000000   ),\n  .GPIO_WIDTH           (1              ),\n  .SPI_NUM_CHIP_SELECT  (1              ))\n\n  rvsteel_mcu_instance  (\n\n  // See I/O signals below for more information.\n\n  .clock                (),\n  .reset                (),\n  .halt                 (),\n  .uart_rx              (),\n  .uart_tx              (),\n  .gpio_input           (),\n  .gpio_oe              (),\n  .gpio_output          (),\n  .sclk                 (),\n  .pico                 (),\n  .poci                 (),\n  .cs                   ());\n</code></pre>"},{"location":"mcu/#configuration-parameters","title":"Configuration parameters","text":"Parameter name and description Value type Default value BOOT_ADDRESSMemory address of the first instruction to be fetched and executed. 32-bit hexadecimal <code>32'h00000000</code> CLOCK_FREQUENCYFrequency (in Hertz) of the <code>clock</code> signal. Integer <code>50000000</code> UART_BAUD_RATEBaud rate of the UART module (in bauds per second). Integer <code>9600</code> MEMORY_SIZESize of the Memory module (in bytes). Integer <code>8192</code> MEMORY_INIT_FILEAbsolute path to the memory initialization file. String <code>(empty string)</code> GPIO_WIDTHNumber of general-purpose I/O pins. Integer <code>1</code> SPI_NUM_CHIP_SELECTNumber of Chip Select (CS) lines for the SPI controller. Integer <code>1</code>"},{"location":"mcu/#io-signals","title":"I/O signals","text":"Pin name and description Direction Size clockClock input. Input 1 bit resetReset pin (active-high). Input 1 bit haltHalt pin (active-high). Input 1 bit uart_rxUART receiver pin. Input 1 bit uart_txUART transmitter pin. Output 1 bit gpio_inputGPIO input signals. Input <code>GPIO_WIDTH</code> gpio_oeGPIO output enable. Output <code>GPIO_WIDTH</code> gpio_outputGPIO output signals. Output <code>GPIO_WIDTH</code> sclkSPI Controller clock. Output 1 bit picoSPI Peripheral In Controller Out. Output 1 bit pociSPI Peripheral Out Controller In. Input 1 bit csSPI Chip Select lines. Output <code>SPI_NUM_CHIP_SELECT</code>"},{"location":"mcu/#memory-map","title":"Memory Map","text":"Start address Final address Block size (Bytes) Device <code>0x00000000</code> <code>0x(MEMORY_SIZE-1)</code> <code>MEMORY_SIZE</code> RAM <code>0x80000000</code> <code>0x8000000f</code> 16 UART <code>0x80010000</code> <code>0x8001001f</code> 32 Timer <code>0x80020000</code> <code>0x8002001f</code> 32 GPIO <code>0x80030000</code> <code>0x8003001f</code> 32 SPI"},{"location":"mcu/#adding-new-devices","title":"Adding new devices","text":"<p>1. Open <code>rvsteel_mcu.v</code> and look for the system bus configuration</p> <pre><code>  // System bus configuration\n\n  localparam NUM_DEVICES    = 5;\n  localparam D0_RAM         = 0;\n  localparam D1_UART        = 1;\n  localparam D2_MTIMER      = 2;\n  localparam D3_GPIO        = 3;\n  localparam D4_SPI         = 4;\n</code></pre> <p>2. Increment the <code>NUM_DEVICES</code> parameter value</p> <p>The <code>NUM_DEVICES</code> parameter sets the total number of devices and is used to size the width of the system bus. </p> <pre><code>  localparam NUM_DEVICES    = 6;\n</code></pre> <p>3. Create a parameter holding the index that will be used to address the new device</p> <p>The system bus configuration should look as follows:</p> <pre><code>  localparam NUM_DEVICES    = 6;\n  localparam D0_RAM         = 0;\n  localparam D1_UART        = 1;\n  localparam D2_MTIMER      = 2;\n  localparam D3_GPIO        = 3;\n  localparam D4_SPI         = 4;\n  localparam D5_NEW_DEVICE  = 5; // your new device\n</code></pre> <p>4. Assign the new device a memory region</p> <p>You can assign the new device to any free region (see Memory Map). The region cannot overlap the address space of other devices and its size must be a power of 2. </p> <p>In the example below, the new device <code>D5_NEW_DEVICE</code> is assigned a 32KB region starting at <code>0x80040000</code>:</p> <pre><code>  wire  [NUM_DEVICES*32-1:0] device_start_address;\n  wire  [NUM_DEVICES*32-1:0] device_region_size;\n\n  assign device_start_address [32*D0_RAM       +: 32]  = 32'h0000_0000;\n  assign device_region_size   [32*D0_RAM       +: 32]  = MEMORY_SIZE;\n\n  assign device_start_address [32*D1_UART      +: 32]  = 32'h8000_0000;\n  assign device_region_size   [32*D1_UART      +: 32]  = 16;\n\n  assign device_start_address [32*D2_MTIMER    +: 32]  = 32'h8001_0000;\n  assign device_region_size   [32*D2_MTIMER    +: 32]  = 32;\n\n  assign device_start_address [32*D3_GPIO      +: 32]  = 32'h8002_0000;\n  assign device_region_size   [32*D3_GPIO      +: 32]  = 32;\n\n  assign device_start_address [32*D4_SPI       +: 32]  = 32'h8003_0000;\n  assign device_region_size   [32*D4_SPI       +: 32]  = 32;\n\n  // Your new device\n  assign device_start_address [32*D5_NEW_DEVICE+: 32]  = 32'h8004_0000;\n  assign device_region_size   [32*D5_NEW_DEVICE+: 32]  = 32768;\n</code></pre> <p>5. Instantiate the new device</p> <p>Finally, you have to instantiate the new device in the <code>rvsteel_mcu</code> module and connect it to the system bus interface.</p> <p>A template for instantiating and connecting the new device to the system bus is provided below:</p> <pre><code>  // Instantiate the new device in the rvsteel_mcu.v module like this:\n\n  new_device\n  new_device_instance (\n\n    // I/O interface of the new device\n\n    .new_device_rw_address      (device_rw_address                        ),\n    .new_device_read_data       (device_read_data[32*D2_NEW_DEVICE +: 32] ),\n    .new_device_read_request    (device_read_request[D2_NEW_DEVICE]       ),\n    .new_device_read_response   (device_read_response[D2_NEW_DEVICE]      ),\n    .new_device_write_data      (device_write_data                        ),\n    .new_device_write_strobe    (device_write_strobe                      ),\n    .new_device_write_request   (device_write_request[D2_NEW_DEVICE]      ),\n    .new_device_write_response  (device_write_response[D2_NEW_DEVICE]     )\n\n  );\n</code></pre> <p>Info</p> <p>RISC-V Steel Processor Core will issue read and write requests to the new device as described in the I/O Operations section. The new device must comply with this protocol.</p> <p> </p>"}]}