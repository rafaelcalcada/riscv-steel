{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Homepage","text":"<ul> <li> <p> What is RISC-V Steel?</p> <p>RISC-V Steel is a free and open collection of RISC-V IP that is simple, robust and easy to use. It features a 32-bit RISC-V processor core, a configurable system-on-chip design and a suite of software and hardware tools aimed to speed up building RISC-V embedded applications.</p> <p> Get started!  GitHub</p> </li> </ul>"},{"location":"#risc-v-steelfree-and-open-risc-v-ip","title":"RISC-V SteelFree and open RISC-V IP","text":""},{"location":"#available-ip","title":"Available RISC-V IP","text":"<ul> <li> <p> System-on-Chip IP</p> <p>A system-on-chip design with RISC-V Steel Processor Core, RAM memory and UART module.</p> <p> Reference  Software Guide</p> </li> <li> <p> Processor Core IP</p> <p>A 32-bit processor core design implementing the RV32I ISA, the Zicsr extension and the Machine-mode privileged architecture of RISC-V.</p> <p> Reference</p> </li> </ul> <p></p>"},{"location":"api/","title":"RISC-V Steel API","text":"<p>RISC-V Steel API is a set of function calls to configure and control RISC-V Steel SoC IP, making it easier to develop applications for it.</p> <p>To start using the API in your application you must include the <code>rvsteel-api.h</code> header in your source code:</p> <pre><code>#include \"rvsteel-api.h\"\n\n// ... your code ...\n</code></pre> <p>This header file is saved in the <code>software-dev/rvsteel-api/</code> folder along with its source code, <code>rvsteel-api.c</code>. The API is compiled and linked to your project by default if you use the template project (located in <code>software-dev/template-project/</code>).</p> <p>The following sections contain detailed information about the available API calls.</p>"},{"location":"api/#uart-communication","title":"UART communication","text":"<p><code>void uart_send_char(const char c);</code></p> <p>Send character c over the UART.</p> <p>This is a blocking call, that is, the execution of the program is halted until the UART finishes sending the data.</p> <pre><code>// Example\n\nuart_send_char('\\n');\n</code></pre> <p><code>void uart_send_string(const char *str);</code></p> <p>Send the null-terminated C-string str over the UART.</p> <p>This is a blocking call, that is, the execution of the program is halted until the UART finishes sending the data.</p> <pre><code>// Example\n\nuart_send_string(\"Hello World!\");\n</code></pre> <p><code>volatile char uart_read_last_char();</code></p> <p>Return the last character received by the UART. The null character <code>'\\0'</code> is returned if no character was received since power up.</p> <p>This is a non-blocking call.</p> <pre><code>// Example\n\nif (uart_read_last_char() == '\\n')\n{\n  uart_send_string(\"Last received character is new line.\");\n}\n</code></pre>"},{"location":"api/#interrupt-handling","title":"Interrupt handling","text":"<p><code>void irq_enable_all();</code></p> <p>Enable external, timer and software interrupts by setting the global interrupt-enable bit in the mstatus CSR and the corresponding interrupt-enable bits in the mie CSR.</p> <pre><code>// Example\n\nirq_enable_all();\n</code></pre> <p><code>void irq_disable_all();</code></p> <p>Disable external, timer and software interrupts by clearing the global interrupt-enable bit in the mstatus CSR and the corresponding interrupt-enable bits in the mie CSR.</p> <pre><code>// Example\n\nirq_disable_all();\n</code></pre> <p><code>void irq_set_interrupt_handler(void (*interrupt_handler)());</code></p> <p>Set the interrupt handler, a routine called everytime an interrupt is accepted.</p> <p>The interrupt handler routine must be a <code>void</code> function with no arguments.</p> <pre><code>// Example\n\nvoid my_custom_interrupt_handler()\n{\n  // simply echoes back the received character\n  char c = uart_read_last_char();\n  uart_send_char(c);\n}\n\nint main()\n{\n  uart_send_string(\"Hello! Type something (it will be echoed back): \");\n  irq_set_interrupt_handler(my_custom_interrupt_handler)\n  irq_enable_all();\n  busy_wait();\n}\n</code></pre>"},{"location":"api/#miscellaneous","title":"Miscellaneous","text":"<p><code>void busy_wait();</code></p> <p>Enter into an infinite loop that can only be stopped by an interrupt request.</p> <p>Make sure interrupts are enabled before calling this method (see <code>irq_enable_all</code>).</p> <pre><code>// Example\n\nvoid my_custom_interrupt_handler()\n{\n  // simply echoes back the received character\n  char c = uart_read_last_char();\n  uart_send_char(c);\n}\n\nint main()\n{\n  uart_send_string(\"Hello! Type something (it will be echoed back): \");\n  irq_set_interrupt_handler(my_custom_interrupt_handler)\n  irq_enable_all();\n  busy_wait();\n}\n</code></pre> <p> </p>"},{"location":"core/","title":"RISC-V Steel Processor Core IP Reference Guide","text":""},{"location":"core/#introduction","title":"Introduction","text":"<p>RISC-V Steel Processor Core is a 32-bit processor core IP implementing the RV32I instruction set, the Zicsr extension and the Machine-mode privileged architecture of RISC-V.</p> <p>RISC-V Steel Processor Core is a single-issue, in-order, unpipelined processor core.</p> <p>RISC-V Steel Processor Core can run real-time operating systems and bare-metal embedded software. It is designed to work as a processing unit in a wide variety of embedded applications.</p>"},{"location":"core/#source-files","title":"Source files","text":"<p>RISC-V Steel Processor Core has a single source file, <code>rvsteel_core.v</code>, saved in the <code>ip/core/</code> folder.</p>"},{"location":"core/#io-signals","title":"I/O signals","text":"<p>Table 1 - RISC-V Steel Processor Core input and output signals</p> Global signals Signal name Direction Size Description clock Input 1 bit Clock input. reset Input 1 bit Reset (active-high). halt Input 1 bit Halts the processor core (active-high). I/O interface Signal name Direction Size Description rw_address Output 32 bits The address for the read/write operation. read_data Input 32 bits The data read from the external device. read_request Output 1 bit This signal is set to logic <code>HIGH</code> when the processor requests to read from an external device. read_response Input 1 bit The response to the read request. write_data Output 32 bits The data to write to the device. write_strobe Output 4 bits A signal indicating which byte lanes of write_data must be written. write_request Output 1 bit This signal is set to logic <code>HIGH</code> when the processor requests to write to an external device. write_response Input 1 bit The response to the write request. Interrupt handling Signal name Direction Size Description irq_external Input 1 bit Drive this signal to logic <code>HIGH</code> to request the processor an external interrupt. irq_external_response Output 1 bit The response to the external interrupt request. irq_timer Input 1 bit Drive this signal to logic <code>HIGH</code> to request the processor a timer interrupt. irq_timer_response Output 1 bit The response to the timer interrupt request. irq_software Input 1 bit Drive this signal to logic <code>HIGH</code> to request the processor a software interrupt. irq_software_response Output 1 bit The response to the software interrupt request. Real time clock Signal name Direction Size Description real_time_clock Input 64 bits The measured time from a real time clock."},{"location":"core/#configuration","title":"Configuration","text":"<p>The only configuration parameter of RISC-V Steel Processor Core is the boot address (<code>BOOT_ADDRESS</code>). In case you leave this parameter blank the boot address is automatically set to <code>32'h00000000</code>.</p>"},{"location":"core/#instantiation-template","title":"Instantiation template","text":"<p>An instantiation template for RISC-V Steel Processor Core top module is provided below.</p> <pre><code>rvsteel_core #(\n\n  // Address of the first instruction to be fetched and executed\n\n  .BOOT_ADDRESS           ()  // defaults to 32'h00000000 if left blank\n\n) rvsteel_core_instance (\n\n  // Global signals\n\n  .clock                  (),\n  .reset                  (), // reset is active-high\n  .halt                   (),\n\n  // IO interface\n\n  .rw_address             (),\n  .read_data              (),\n  .read_request           (),\n  .read_response          (),\n  .write_data             (),\n  .write_strobe           (),\n  .write_request          (),\n  .write_response         (),\n\n  // Interrupt signals\n\n  .irq_external           (), // hardwire to 1'b0 if unused\n  .irq_external_response  (), // leave blank if unused\n  .irq_timer              (), // hardwire to 1'b0 if unused\n  .irq_timer_response     (), // leave blank if unused\n  .irq_software           (), // hardwire to 1'b0 if unused\n  .irq_software_response  (), // leave blank if unused\n\n  // Real Time Clock\n\n  .real_time_clock        ()  // hardwire to 64'b0 if unused\n\n);\n</code></pre>"},{"location":"core/#io-operations","title":"I/O operations","text":"<p>RISC-V Steel Processor Core communicates with external devices (memory and peripherals) through its I/O interface signals (see Table 1). In each clock cycle the processor either requests to read or write data (it never requests both operations in the same clock cycle).</p> <p>As in all RISC-V systems, the processor address space is shared among all devices, both memory and peripherals. Each device is mapped to a region in the address space. Communication with a device takes place by reading and writing data at addresses assigned exclusively to that device.</p> <p>For example, a system with a 16 KB memory and a UART module could split the processor address space as follows:</p> <ul> <li>the memory would be assigned the address range from 0x00000000 to 0x00003fff</li> <li>the address 0x80000000 would be used to send and receive data from the UART module</li> <li>all remaining addresses would be free to be used by other devices</li> </ul> <p>The two sections below explain how read and write operations are requested by the processor core and the expected response to these requests.</p>"},{"location":"core/#read-operation","title":"Read operation","text":"<p>The processor core drives the I/O interface signals as follows when making a read request:</p> <ul> <li> <p>the address is placed in the rw_address bus.</p> </li> <li> <p>the read_request signal is driven to logic <code>HIGH</code>.</p> </li> <li> <p>the rw_address and read_request signals remain stable until read_response is driven to logic <code>HIGH</code> by the external device.</p> </li> </ul> <p>The response to the read request from the external device must observe these rules:</p> <ul> <li> <p>The read data must be placed in the read_data bus.</p> </li> <li> <p>the read_response signal must be driven to logic <code>HIGH</code> only when read_data holds valid data, and it must be held <code>HIGH</code> for only one clock cycle.</p> </li> <li> <p>The read response must never be given in the same clock cycle that read_request was driven <code>HIGH</code>.</p> </li> </ul> <p>The timing diagram below contains examples of valid read operations:</p> <p> </p> Figure 1 - Read operation timing diagram"},{"location":"core/#write-operation","title":"Write operation","text":"<p>The processor core drives the I/O interface signals as follows when making a write request:</p> <ul> <li> <p>the address is placed in the rw_address bus.</p> </li> <li> <p>the write_request signal is driven to logic <code>HIGH</code>.</p> </li> <li> <p>the data to be written is placed in the write_data bus.</p> </li> <li> <p>the write_strobe signal will indicate which byte lanes of write_data must be written.</p> <p>For example, if this signal holds <code>4'b0001</code>, only the least significant byte must be written. The upper 24 bits of write_data must be ignored.</p> </li> <li> <p>all signals above remain stable until write_response is driven to logic <code>HIGH</code> by the external device.</p> </li> </ul> <p>The response to the write request from the external device must observe these rules:</p> <ul> <li> <p>the write_response signal must be driven to logic <code>HIGH</code> only if the write operation succeeded, and it must be held <code>HIGH</code> for only one clock cycle.</p> </li> <li> <p>The write response must never be given in the same clock cycle that write_request was driven <code>HIGH</code>.</p> </li> </ul> <p>The timing diagram below contains examples of valid write operations:</p> <p> </p> Figure 2 - Write operation timing diagram"},{"location":"core/#interrupts","title":"Interrupts","text":"<p>There are three interrupt types in the RISC-V architecture: external, timer, and software. RISC-V Steel Processor Core provides dedicated signals (irq_external, irq_timer and irq_software) to request each of these interrupt types.</p> <p>A device can request an interrupt by driving the irq_* signal to logic <code>HIGH</code> and holding it <code>HIGH</code> until the request is accepted. The processor accepts the request by driving the irq_*_response signal to logic <code>HIGH</code> for one clock cycle. The requesting device can drive the irq_* signal to logic <code>LOW</code> in the clock cycle that follows the response, or keep it <code>HIGH</code> to make a new request.</p> <p>The timing diagram below is an example of a valid interrupt request:</p> <p> </p> Figure 3 - Interrupt request timing diagram <p>An interrupt request is accepted if:</p> <ul> <li> <p>the global interrupt enable bit is set (field mie in the mstatus CSR), and</p> </li> <li> <p>the corresponding interrupt type is enabled (fields meie, mtie and msie in the mie CSR).</p> </li> </ul> <p>The processor proceeds as follows when an interrupt request is accepted:</p> <ul> <li> <p>the execution of the current instruction is aborted.</p> </li> <li> <p>the memory address of the aborted instruction is saved in the mepc CSR.</p> </li> <li> <p>the program counter is set to the value of the mtvec CSR.</p> </li> <li> <p>the mcause CSR is set to a value encoding the type of the interrupt.</p> </li> <li> <p>the global interrupt enable bit mstatus.mie is set to logic <code>LOW</code>, disabling new interrupts.</p> </li> <li> <p>the prior interrupt enable bit mstatus.mpie is set to logic <code>HIGH</code>.</p> </li> <li> <p>the corresponding response signal (irq_*_response) is set to logic <code>HIGH</code> for one clock cycle.</p> </li> </ul> <p>The mtvec CSR is set by software to the address of an interrupt handler routine, so the core branches from normal execution and starts the execution of the interrupt handler.</p> <p>The mret instruction is used by software to return from the interrupt handler. When this instruction is executed the core proceeds as follows:</p> <ul> <li> <p>the program counter is set to the value of the mepc CSR.</p> </li> <li> <p>the global interrupt enable bit mstatus.mie receives the value saved in the mstatus.mpie bit.</p> </li> <li> <p>the prior interrupt enable bit mstatus.mpie is set to logic <code>LOW</code>. </p> </li> </ul> <p>The value in the mepc register is the address of the instruction aborted by the interrupt, so normal execution is resumed.</p>"},{"location":"core/#real-time-clock","title":"Real time clock","text":"<p>Systems that require a real time clock can connect the time CSR to an external clock device through the real_time_clock bus. By doing so, wall clock time can be obtained by reading the time CSR with the csrrw instruction.</p> <p>Systems that do not need a real time clock can hardwire this signal to <code>64'b0</code>, which causes reading the time CSR to return zero. In this case time lapses can still be measured by reading the cycle counter mcycle, as long as the clock signal is connected to a stable oscillating signal.</p> <p> </p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This guide shows you how to synthesize the Hello World demo for some popular FPGAs so you can quickly get started with RISC-V Steel SoC IP.</p> <p>The Hello World demo is an instance of the SoC IP that sends a Hello World message to a host computer via UART protocol. Its goal is to introduce you to the SoC design so that you can expand it and develop your own embedded applications.</p>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<p>To follow this guide you'll need one of the following FPGA boards:</p> <ul> <li> <p>Digilent Arty A7</p> </li> <li> <p>Digilent Cmod A7</p> </li> </ul> <p>Also, make sure you have the following software installed on your computer:</p> <ul> <li> <p>AMD Xilinx Vivado</p> <p>The latest version of AMD Xilinx Vivado is available for download here.</p> <p>During installation, remember to include support for the Artix-7 device family and the cable drivers.</p> </li> <li> <p>PySerial</p> <p>PySerial is a Python package for communication over serial protocol. It can be installed by running:</p> <pre><code>python -m pip install pyserial\n</code></pre> </li> </ul>"},{"location":"getting-started/#get-risc-v-steel","title":"Get RISC-V Steel","text":"<p>Clone RISC-V Steel repository from GitHub:</p> <pre><code>git clone https://github.com/riscv-steel/riscv-steel.git\n</code></pre>"},{"location":"getting-started/#start-pyserial","title":"Start PySerial","text":"<p>Connect the board to your computer using a USB cable and start PySerial terminal by running:</p> <pre><code>python -m serial.tools.miniterm\n</code></pre> <p>A list of available serial ports will follow. Select the port your board is connected to and keep the terminal open for the next steps.</p> <p></p>"},{"location":"getting-started/#program-the-fpga","title":"Program the FPGA","text":"<p>Open AMD Xilinx Vivado and follow the steps:</p> <ol> <li> <p>Click Run Tcl Script in the Tools menu.</p> </li> <li> <p>Search for <code>create-project-XXX.tcl</code> and click Ok. <code>XXX</code> stands for your board name.</p> <p>This file is located at <code>hello-world/XXX/</code>.</p> <p>Running this script will create a new Vivado project for your FPGA board with the Hello World demo.</p> <p>To save your time, we provide a precompiled bitstream to program the FPGA in the same directory as the script.</p> <p>Generating the bitstream might be a bit slow. If you want to generate it anyway click Generate Bitstream in the Flow menu.</p> </li> <li> <p>Click Open Hardware Manager in the Flow menu.</p> </li> <li> <p>Click Auto Connect in the Tools menu.</p> </li> <li> <p>The hardware box will show the name of your device.</p> </li> <li> <p>Right-click on your device name and next on Program Device.</p> </li> <li> <p>A dialog box asking you to provide the bitstream will open.</p> </li> <li> <p>Search for <code>hello_world_XXX.bit</code>.</p> <p>This file is located at <code>hello-world/XXX/</code>.</p> <p>In case you generated the bitstream yourself you can find it at <code>hello-world/XXX/hello-world-XXX/hello-world-XXX.runs/impl_1</code>.</p> </li> <li> <p>Click on Program and wait for Vivado to finish programming the FPGA.</p> </li> </ol> <p>Now go back to PySerial terminal window. You should see the message below:</p> <p></p>"},{"location":"getting-started/#next-steps","title":"Next steps","text":"<p>If you've reached this point, congratulations! You have a working instance of the SoC IP. You can now change it to create your own embedded applications.</p> <ul> <li> <p>Run your own software</p> <p>In the SoC IP Software Guide you find how to write, compile, and run software applications for RISC-V Steel SoC IP.</p> </li> <li> <p>Expand the hardware</p> <p>In the SoC IP Reference Guide you find detailed information about the design so that you can expand it to create larger projects.</p> </li> </ul> <p> </p>"},{"location":"license/","title":"License","text":"<p>RISC-V Steel is free and open. It is distributed under the MIT License, reproduced below.</p> <p> <p>Copyright (c) 2020-2024 RISC-V Steel contributors</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p> <p></p>"},{"location":"soc/","title":"RISC-V Steel System-on-Chip IP Reference Guide","text":""},{"location":"soc/#introduction","title":"Introduction","text":"<p>RISC-V Steel SoC IP is a system-on-chip design with RISC-V Steel Processor Core, RAM memory and UART module. It comes with an API for software development that makes it easier for hardware engineers to develop and deploy RISC-V embedded applications.</p> <p>In this Reference Guide you find information on the SoC IP hardware design. See the Software Guide for instructions on how to write, compile and run software for the SoC IP.</p>"},{"location":"soc/#design-overview","title":"Design overview","text":"<p>Figure 1 - RISC-V Steel SoC IP design overview</p> <p></p>"},{"location":"soc/#source-files","title":"Source files","text":"<p>Table 1 - RISC-V Steel SoC IP source files</p> Module name File Location Description rvsteel_soc <code>rvsteel_soc.v</code> <code>ip/soc/</code> Top module of RISC-V Steel SoC IP rvsteel_core <code>rvsteel_core.v</code> <code>ip/core/</code> RISC-V Steel Processor Core ram_memory <code>ram_memory.v</code> <code>ip/soc</code> RAM memory uart <code>uart.v</code> <code>ip/soc</code> UART system_bus <code>system_bus.v</code> <code>ip/soc</code> System Bus"},{"location":"soc/#io-signals","title":"I/O signals","text":"<p>Table 2 - RISC-V Steel SoC IP top module input and output signals</p> Pin name Direction Size Description clock Input 1 bit Clock input. reset Input 1 bit Reset (active-high). halt Input 1 bit Halts the processor core (active-high). uart_rx Input 1 bit UART receiver pin. Must be connected to the transmitter (<code>TX</code>) pin of another UART device. uart_tx Output 1 bit UART transmitter pin. Must be connected to the receiver (<code>RX</code>) pin of another UART device."},{"location":"soc/#memory-map","title":"Memory Map","text":"<p>In RISC-V systems, all devices share the processor address space and are mapped to an exclusive region in it (Memory Mapped I/O). </p> <p>The memory region assigned to each device of RISC-V Steel SoC IP is listed in the table below.</p> <p>Table 4 - Memory Map of RISC-V Steel SoC IP</p> Start address Final address Mapped device <code>0x00000000</code> <code>0x(MEMORY_SIZE-1)</code> RAM memory <code>0x(MEMORY_SIZE)</code> <code>0x7fffffff</code> - <code>0x80000000</code> <code>0x80000004</code> UART <code>0x80000005</code> <code>0xffffffff</code> -"},{"location":"soc/#configuration","title":"Configuration","text":"<p>Table 3 - Configuration parameters of RISC-V Steel SoC IP</p> Parameter name Default value Value type and description <code>BOOT_ADDRESS</code> <code>32'h00000000</code> 32-bit hexadecimal value. Memory address of the first instruction to be fetched and executed. <code>CLOCK_FREQUENCY</code> <code>50000000</code> Integer. Frequency (in hertz) of the clock input signal. <code>UART_BAUD_RATE</code> <code>9600</code> Integer. UART baud rate (in bauds per second). <code>MEMORY_SIZE</code> <code>8192</code> Integer. RAM memory size (in bytes). <code>MEMORY_INIT_FILE</code> <code>(empty string)</code> String. Path to a memory initialization file."},{"location":"soc/#instantiation-template","title":"Instantiation template","text":"<p>An instantiation template for RISC-V Steel SoC IP top module is provided below.</p> <pre><code>rvsteel_soc #(\n\n  // Configuration parameters. For more information read the 'Configuration'\n  // section of RISC-V Steel SoC IP Reference Guide\n\n  .BOOT_ADDRESS             (),  // Default value: 32'h00000000\n  .CLOCK_FREQUENCY          (),  // Default value: 50000000\n  .UART_BAUD_RATE           (),  // Default value: 9600\n  .MEMORY_SIZE              (),  // Default value: 8192\n  .MEMORY_INIT_FILE         ())  // Default value: Empty string (uninitialized)\n\n  rvsteel_soc_instance (\n\n  // I/O signals. For more information read the 'I/O signals'\n  // section of RISC-V Steel SoC IP Reference Guide\n\n  .clock                    (),  // Connect this pin to a clock source\n  .reset                    (),  // Connect this pin to a switch/button or hardwire it to 1'b0.\n  .halt                     (),  // Connect this pin to a switch/button or hardwire it to 1'b0.\n  .uart_rx                  (),  // Connect this pin to the TX pin of another UART device\n  .uart_tx                  ()   // Connect this pin to the RX pin of another UART device\n\n);\n</code></pre>"},{"location":"soc/#how-to-add-new-devices","title":"How to add new devices","text":"<p>You can integrate a new device into the SoC IP design by making simple changes to its top module. The following lines of <code>rvsteel_soc.v</code> contain the parameters you need to change:</p> <pre><code>  // System bus configuration\n\n  localparam NUM_DEVICES    = 2;\n  localparam D0_RAM         = 0;\n  localparam D1_UART        = 1;\n\n  wire  [NUM_DEVICES*32-1:0] device_start_address;     \n  wire  [NUM_DEVICES*32-1:0] device_region_size;\n\n  assign device_start_address [32*D0_RAM  +: 32]  = 32'h0000_0000;\n  assign device_region_size   [32*D0_RAM  +: 32]  = 8192;\n\n  assign device_start_address [32*D1_UART +: 32]  = 32'h8000_0000;\n  assign device_region_size   [32*D1_UART +: 32]  = 8;\n</code></pre> <p>The <code>NUM_DEVICES</code> parameter holds the total number of devices in the system. Each device is assigned an index (<code>D0_RAM</code> and <code>D1_UART</code>). To accomodate your new device you need to increase <code>NUM_DEVICES</code> and assign it the next index, <code>2</code>, like this:</p> <pre><code>  localparam NUM_DEVICES    = 3;\n  localparam D0_RAM         = 0;\n  localparam D1_UART        = 1;\n  localparam D2_NEW_DEVICE  = 2; // your new device\n</code></pre> <p>Next you have to assign your device a region in the processor's address space. You can assign it to any free region (see Memory Map). The region cannot overlap the address space of other devices and its size must be a power of 2. In the example below, the new device <code>D2_NEW_DEVICE</code> is assigned a 32KB region starting at <code>0x00008000</code>:</p> <pre><code>  assign device_start_address [32*D2_NEW_DEVICE +: 32]  = 32'h0000_8000;\n  assign device_region_size   [32*D2_NEW_DEVICE +: 32]  = 32768;\n</code></pre> <p>Finally, you have to instantiate the new device in the <code>rvsteel_soc</code> module and connect it to the system bus interface. The Processor Core IP will issue read and write requests to your device as described in the I/O Operations section of its Reference Guide. A template for instantiating and connecting the new device to the system bus is provided below:</p> <pre><code>  /* Instantiate the new device in the rvsteel_soc.v module like this: */\n\n  new_device\n  new_device_instance (\n\n    /* I/O interface of the new device */\n\n    .new_device_rw_address      (device_rw_address                        ),\n    .new_device_read_data       (device_read_data[32*D2_NEW_DEVICE +: 32] ),\n    .new_device_read_request    (device_read_request[D2_NEW_DEVICE]       ),\n    .new_device_read_response   (device_read_response[D2_NEW_DEVICE]      ),\n    .new_device_write_data      (device_write_data                        ),\n    .new_device_write_strobe    (device_write_strobe                      ),\n    .new_device_write_request   (device_write_request[D2_NEW_DEVICE]      ),\n    .new_device_write_response  (device_write_response[D2_NEW_DEVICE]     )\n\n  );\n</code></pre>"},{"location":"soc/#components","title":"Components","text":""},{"location":"soc/#risc-v-steel-processor-core","title":"RISC-V Steel Processor Core","text":"<p>RISC-V Steel Processor Core is the processing unit of RISC-V Steel SoC IP. Its design is quite large so it has its own Reference Guide. Please check it out for more information.</p>"},{"location":"soc/#ram-memory","title":"RAM memory","text":"<p>RISC-V Steel SoC IP has a RAM memory tightly coupled to the processor core, with read/write latency of a single clock cycle. The memory size can be changed by adjusting the <code>MEMORY_SIZE</code> parameter (see Configuration). </p>"},{"location":"soc/#uart","title":"UART","text":"<p>RISC-V Steel SoC IP has an UART module with configurable baud rate. The module works with 8 data bits, 1 stop bit, no parity bits and no flow control signals (most UARTs work the same way).</p>"},{"location":"soc/#system-bus","title":"System Bus","text":"<p>The system bus module interconnects RISC-V Steel Processor Core (manager device) to the UART and the RAM memory (subordinate devices) as shown in Figure 1. The module multiplexes the signals from the processor's I/O interface to the appropriate subordinate device according to the address the processor requests.</p> <p> </p>"},{"location":"software-guide/","title":"Software Guide","text":""},{"location":"software-guide/#introduction","title":"Introduction","text":"<p>In this guide you find instruction on how to write, compile and run software applications for RISC-V Steel SoC IP.</p>"},{"location":"software-guide/#prerequisites","title":"Prerequisites","text":"<p>To compile, assemble and link programs for the RISC-V architecture you need the RISC-V GNU Toolchain. Follow the steps below to install and configure it for use with RISC-V Steel:</p> 1. Get the source files <pre><code>git clone https://github.com/riscv/riscv-gnu-toolchain\n</code></pre> 2. Install dependencies UbuntuFedora/CentOS/RHEL OSArch LinuxOS X <pre><code>sudo apt-get install autoconf automake autotools-dev curl python3 python3-pip libmpc-dev libmpfr-dev libgmp-dev gawk build-essential bison flex texinfo gperf libtool patchutils bc zlib1g-dev libexpat-dev ninja-build git cmake libglib2.0-dev\n</code></pre> <pre><code>sudo yum install autoconf automake python3 libmpc-devel mpfr-devel gmp-devel gawk  bison flex texinfo patchutils gcc gcc-c++ zlib-devel expat-devel\n</code></pre> <pre><code>sudo pacman -Syyu autoconf automake curl python3 libmpc mpfr gmp gawk base-devel bison flex texinfo gperf libtool patchutils bc zlib expat\n</code></pre> <pre><code>brew install python3 gawk gnu-sed gmp mpfr libmpc isl zlib expat texinfo flock\n</code></pre> 3. Configure it for RISC-V Steel <pre><code>./configure --with-arch=rv32i --with-abi=ilp32 --prefix=/opt/riscv\n</code></pre> 4. Compile and install <pre><code>make -j $(nproc)\n</code></pre>"},{"location":"software-guide/#building-a-new-application","title":"Building a new application","text":"1. Make a copy of the software development template project. <p>The template project is all you need to start and is located at <code>software-dev/template-project/</code>.</p> 2. Edit the Makefile. <p>The template project comes with a Makefile to help you automate the tasks of compiling the software and generating a memory initialization file.</p> <p>The beginning of the Makefile (reproduced below) contain the four variables you need to set to configure the project:</p> <pre><code># Configure your project by setting the variables below\n# -------------------------------------------------------------------------------------------------\n\n# Name of the program to be created\nPROGRAM_NAME      ?= main\n# Memory size (must be set to the same value of the MEMORY_SIZE parameter of rvsteel_soc module)\nMEMORY_SIZE       ?= 8192\n# Path to RISC-V Steel API\nRVSTEEL_API_DIR   ?= ../rvsteel-api\n# The full path to RISC-V GNU Toolchain binaries in this machine + RISC-V binaries prefix\nRISCV_PREFIX      ?= /opt/riscv/bin/riscv32-unknown-elf-\n</code></pre> 3. Write your application. <p>The template project comes with a <code>main.c</code> file containing a Hello World example. You can edit this file, rename it or delete it.</p> <p>You can add as many source files to the project as you want. The Makefile was written so that all <code>*.c</code> source files you add to the project get automatically compiled when you run <code>make</code>.</p> <p>To make it easier to develop your application, RISC-V Steel API provides function calls to configure and control the SoC IP. Check it out for more information.</p> 4. Build your application. <p>Run <code>make</code> from the project root folder to build your application and generate a memory initialization file. A successfull build output is similar to this:</p> <pre><code>Building RISC-V Steel API: ok.\nMaking my_app.o: ok.\nMaking srcfile1.o: ok.\nMaking srcfile2.o: ok.\nLinking my_app.elf: ok.\n\nGenerated files:\n-- ELF executable   : build/my_app.elf\n-- Disassembly      : build/my_app.objdump\n-- Memory init file : build/my_app.hex\n\nThe memory size is set to 8192 bytes.\n</code></pre> <p>The generated <code>.hex</code> file can now be used to initialize RISC-V Steel SoC IP memory and run the application.</p>"},{"location":"software-guide/#running-the-application","title":"Running the application","text":"1. Specify the path to the memory initialization file <p>The SoC IP has a parameter called <code>MEMORY_INIT_FILE</code> that can be set when instantiating its top module. If you specify this parameter the RAM memory will be initialized with the contents of the memory file that you provided. </p> <p>In the example below (that you can find at <code>hello-world/arty-a7/hello-world-arty-a7.v</code>) an instance of the SoC IP for the Digilent Arty-A7 FPGA board is configured to load a Hello World program:</p> <pre><code>rvsteel_soc                  #(\n    .CLOCK_FREQUENCY          (50000000           ),\n    .UART_BAUD_RATE           (9600               ),\n    .MEMORY_SIZE              (8192               ),\n    .MEMORY_INIT_FILE         (\"hello-world.hex\"  ),\n    .BOOT_ADDRESS             (32'h00000000       ))\nrvsteel_soc_instance          ( \n    .clock                    (clock_50mhz        ),\n    .reset                    (reset              ),\n    .uart_rx                  (uart_rx            ),\n    .uart_tx                  (uart_tx            ));\n</code></pre> 2. Set the boot address (if needed) <p>If you did not use the template project for making your application then you'll need to set the <code>BOOT_ADDRESS</code> parameter to point to the entry symbol of your application.</p> <p>The <code>BOOT_ADDRESS</code> parameter does not need to be set if you generated the memory init file with the template project Makefile. In this case, a small boot code is automatically added to your application and the linker script in the template project places this boot code at <code>0x00000000</code> (which is the default boot address).</p> 3. Update the bitstream of your FPGA <p>After configuring the parameters of your instance of the SoC IP, generate a new bitstream and upload it to your FPGA. The application will start running automatically when you power up the board.</p> <p> </p>"}]}