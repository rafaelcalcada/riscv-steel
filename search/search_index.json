{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Homepage","text":""},{"location":"#risc-v-steelfree-and-open-risc-v-ip","title":"RISC-V SteelFree and open RISC-V IP","text":""},{"location":"#what-is-risc-v-steel","title":"What is RISC-V Steel?","text":"<p>RISC-V Steel is a free and open collection of RISC-V IP that is simple, robust and easy to use. It features a 32-bit RISC-V processor core, a configurable system-on-chip design and a suite of software and hardware tools aimed to speed up building RISC-V embedded applications.</p> <p> Get started!  GitHub</p>"},{"location":"#available-ip","title":"Available IP","text":""},{"location":"#processor-core","title":"Processor Core","text":"<p>RISC-V Steel Processor Core implements the RV32I ISA, the Zicsr extension and the Machine-mode privileged architecture of RISC-V.</p> <p> Documentation</p>"},{"location":"#system-on-chip","title":"System-on-Chip","text":"<p>RISC-V Steel System-on-Chip expands the Processor Core IP by adding memory and UART modules to its design. It features a toolchain for software development and demo projects.</p> <p> Documentation  Software Guide</p> <p></p>"},{"location":"api/","title":"RISC-V Steel System-on-Chip","text":"Software API"},{"location":"api/#introduction","title":"Introduction","text":"<p>The Software API of RISC-V Steel System-on-Chip IP provides function calls to configure and control the devices in the system, making it easy to write applications for it.</p> <p>To use it you need to include the <code>rvsteel_api.h</code> header in the source code of your application:</p> <pre><code>#include \"rvsteel_api.h\"\n</code></pre> <p>The sections below contain documentation of the available API calls.</p>"},{"location":"api/#uart-communication","title":"UART communication","text":""},{"location":"api/#uart_send_char","title":"uart_send_char","text":"<p><code>void uart_send_char(const char c);</code></p> <p>Send character c over the UART.</p> <p>This is a blocking call, that is, the execution of the program is halted until the UART finishes sending the data.</p> <pre><code>// Example\n\nuart_send_char('\\n');\n</code></pre>"},{"location":"api/#uart_send_string","title":"uart_send_string","text":"<p><code>void uart_send_string(const char *str);</code></p> <p>Send the null-terminated C-string str over the UART.</p> <p>This is a blocking call, that is, the execution of the program is halted until the UART finishes sending the data.</p> <pre><code>// Example\n\nuart_send_string(\"Hello World!\");\n</code></pre>"},{"location":"api/#uart_read_last_char","title":"uart_read_last_char","text":"<p><code>volatile char uart_read_last_char();</code></p> <p>Return the last character received by the UART. The null character <code>'\\0'</code> is returned if no character was received since power up.</p> <p>This is a non-blocking call.</p> <pre><code>// Example\n\nif (uart_read_last_char() == '\\n')\n{\n  uart_send_string(\"Last received character is new line.\");\n}\n</code></pre>"},{"location":"api/#interrupt-handling","title":"Interrupt handling","text":""},{"location":"api/#irq_enable_all","title":"irq_enable_all","text":"<p><code>void irq_enable_all();</code></p> <p>Enable external, timer and software interrupts by setting the global interrupt-enable bit in the mstatus CSR and the corresponding interrupt-enable bits in the mie CSR.</p> <pre><code>// Example\n\nirq_enable_all();\n</code></pre>"},{"location":"api/#irq_disable_all","title":"irq_disable_all","text":"<p><code>void irq_disable_all();</code></p> <p>Disable external, timer and software interrupts by clearing the global interrupt-enable bit in the mstatus CSR and the corresponding interrupt-enable bits in the mie CSR.</p> <pre><code>// Example\n\nirq_disable_all();\n</code></pre>"},{"location":"api/#irq_set_interrupt_handler","title":"irq_set_interrupt_handler","text":"<p><code>void irq_set_interrupt_handler(void (*interrupt_handler)());</code></p> <p>Set the interrupt handler, a routine called everytime an interrupt is accepted.</p> <p>The interrupt handler routine must be a <code>void</code> function with no arguments.</p> <pre><code>// Example\n\nvoid my_custom_interrupt_handler()\n{\n  // simply echoes back the received character\n  char c = uart_read_last_char();\n  uart_send_char(c);\n}\n\nint main()\n{\n  uart_send_string(\"Hello! Type something (it will be echoed back): \");\n  irq_set_interrupt_handler(my_custom_interrupt_handler)\n  irq_enable_all();\n  busy_wait();\n}\n</code></pre>"},{"location":"api/#miscellaneous","title":"Miscellaneous","text":""},{"location":"api/#busy_wait","title":"busy_wait","text":"<p><code>void busy_wait();</code></p> <p>Enter into an infinite loop that can only be stopped by an interrupt request.</p> <p>Make sure interrupts are enabled before calling this method (see <code>irq_enable_all</code>).</p> <pre><code>// Example\n\nvoid my_custom_interrupt_handler()\n{\n  // simply echoes back the received character\n  char c = uart_read_last_char();\n  uart_send_char(c);\n}\n\nint main()\n{\n  uart_send_string(\"Hello! Type something (it will be echoed back): \");\n  irq_set_interrupt_handler(my_custom_interrupt_handler)\n  irq_enable_all();\n  busy_wait();\n}\n</code></pre> <p> </p>"},{"location":"core/","title":"RISC-V Steel Processor Core","text":"Documentation"},{"location":"core/#introduction","title":"Introduction","text":"<p>RISC-V Steel Processor Core is a 32-bit processor core IP implementing the RV32I instruction set, the Zicsr extension and the Machine-mode privileged architecture of RISC-V.</p> <p>RISC-V Steel Processor Core is a single-issue, in-order, unpipelined processor core.</p> <p>RISC-V Steel Processor Core can run real-time operating systems and bare-metal embedded software. It is designed to work as a processing unit in a wide variety of embedded applications.</p>"},{"location":"core/#source-files","title":"Source files","text":"<p>RISC-V Steel Processor Core has a single source file, <code>rvsteel_core.v</code>, saved in the <code>hardware/core/</code> folder.</p>"},{"location":"core/#io-signals","title":"I/O signals","text":"<p>Table 1 - RISC-V Steel Processor Core input and output signals</p> Global signals Signal name Direction Size Description clock Input 1 bit Clock input. reset Input 1 bit Reset (active-high). halt Input 1 bit Halts the processor core (active-high). I/O interface Signal name Direction Size Description rw_address Output 32 bits The address for the read/write operation. read_data Input 32 bits The data read from the external device. read_request Output 1 bit This signal is set to logic <code>HIGH</code> when the processor requests to read from an external device. read_response Input 1 bit The response to the read request. write_data Output 32 bits The data to write to the device. write_strobe Output 4 bits A signal indicating which byte lanes of write_data must be written. write_request Output 1 bit This signal is set to logic <code>HIGH</code> when the processor requests to write to an external device. write_response Input 1 bit The response to the write request. Interrupt handling Signal name Direction Size Description irq_external Input 1 bit Drive this signal to logic <code>HIGH</code> to request the processor an external interrupt. irq_external_response Output 1 bit The response to the external interrupt request. irq_timer Input 1 bit Drive this signal to logic <code>HIGH</code> to request the processor a timer interrupt. irq_timer_response Output 1 bit The response to the timer interrupt request. irq_software Input 1 bit Drive this signal to logic <code>HIGH</code> to request the processor a software interrupt. irq_software_response Output 1 bit The response to the software interrupt request. Real time clock Signal name Direction Size Description real_time_clock Input 64 bits The measured time from a real time clock."},{"location":"core/#configuration","title":"Configuration","text":"<p>The only configuration parameter of RISC-V Steel Processor Core is the boot address (<code>BOOT_ADDRESS</code>). In case you leave this parameter blank the boot address is automatically set to <code>32'h00000000</code>.</p>"},{"location":"core/#instantiation-template","title":"Instantiation template","text":"<p>An instantiation template for RISC-V Steel Processor Core top module is provided below.</p> <pre><code>rvsteel_core #(\n\n  // Address of the first instruction to be fetched and executed\n\n  .BOOT_ADDRESS           ()  // defaults to 32'h00000000 if left blank\n\n) rvsteel_core_instance (\n\n  // Global signals\n\n  .clock                  (),\n  .reset                  (), // reset is active-high\n  .halt                   (),\n\n  // IO interface\n\n  .rw_address             (),\n  .read_data              (),\n  .read_request           (),\n  .read_response          (),\n  .write_data             (),\n  .write_strobe           (),\n  .write_request          (),\n  .write_response         (),\n\n  // Interrupt signals\n\n  .irq_external           (), // hardwire to 1'b0 if unused\n  .irq_external_response  (), // leave blank if unused\n  .irq_timer              (), // hardwire to 1'b0 if unused\n  .irq_timer_response     (), // leave blank if unused\n  .irq_software           (), // hardwire to 1'b0 if unused\n  .irq_software_response  (), // leave blank if unused\n\n  // Real Time Clock\n\n  .real_time_clock        ()  // hardwire to 64'b0 if unused\n\n);\n</code></pre>"},{"location":"core/#io-operations","title":"I/O operations","text":"<p>RISC-V Steel Processor Core communicates with external devices (memory and peripherals) through its I/O interface signals (see Table 1). In each clock cycle the processor either requests to read or write data (it never requests both operations in the same clock cycle).</p> <p>As in all RISC-V systems, the processor address space is shared among all devices, both memory and peripherals. Each device is mapped to a region in the address space. Communication with a device takes place by reading and writing data at addresses assigned exclusively to that device.</p> <p>For example, a system with a 16 KB memory and a UART module could split the processor address space as follows:</p> <ul> <li>the memory would be assigned the address range from 0x00000000 to 0x00003fff</li> <li>the address 0x80000000 would be used to send and receive data from the UART module</li> <li>all remaining addresses would be free to be used by other devices</li> </ul> <p>The two sections below explain how read and write operations are requested by the processor core and the expected response to these requests.</p>"},{"location":"core/#read-operation","title":"Read operation","text":"<p>The processor core drives the I/O interface signals as follows on a read request:</p> <ul> <li> <p>the address is placed in the rw_address bus.</p> </li> <li> <p>the read_request signal is driven to logic <code>HIGH</code>.</p> </li> <li> <p>the rw_address and read_request signals remain stable until read_response is driven to logic <code>HIGH</code> by the external device.</p> </li> </ul> <p>The response to the read request from the external device must observe these rules:</p> <ul> <li> <p>The read data must be placed in the read_data bus.</p> </li> <li> <p>the read_response signal must be driven to logic <code>HIGH</code> only when read_data holds valid data, and it must be held <code>HIGH</code> for only one clock cycle.</p> </li> <li> <p>The read response must never be given in the same clock cycle that read_request was driven <code>HIGH</code>.</p> </li> </ul> <p>The timing diagram below contains examples of valid read operations:</p> <p> </p> Figure 1 - Read operation timing diagram"},{"location":"core/#write-operation","title":"Write operation","text":"<p>The processor core drives the I/O interface signals as follows on a write request:</p> <ul> <li> <p>the address is placed in the rw_address bus.</p> </li> <li> <p>the write_request signal is driven to logic <code>HIGH</code>.</p> </li> <li> <p>the data to be written is placed in the write_data bus.</p> </li> <li> <p>the write_strobe signal will indicate which byte lanes of write_data must be written.</p> <p>For example, if this signal holds <code>4'b0001</code>, only the least significant byte must be written. The upper 24 bits of write_data must be ignored.</p> </li> <li> <p>all signals above remain stable until write_response is driven to logic <code>HIGH</code> by the external device.</p> </li> </ul> <p>The response to the write request from the external device must observe these rules:</p> <ul> <li> <p>the write_response signal must be driven to logic <code>HIGH</code> only if the write operation succeeded, and it must be held <code>HIGH</code> for only one clock cycle.</p> </li> <li> <p>The write response must never be given in the same clock cycle that write_request was driven <code>HIGH</code>.</p> </li> </ul> <p>The timing diagram below contains examples of valid write operations:</p> <p> </p> Figure 2 - Write operation timing diagram"},{"location":"core/#interrupt-handling","title":"Interrupt handling","text":"<p>There are three interrupt types in the RISC-V architecture: external, timer, and software. RISC-V Steel Processor Core provides dedicated signals (irq_external, irq_timer and irq_software) to request each of these interrupt types.</p> <p>A device can request an interrupt by driving the irq_* signal to logic <code>HIGH</code> and holding it <code>HIGH</code> until the request is accepted. The processor accepts the request by driving the irq_*_response signal to logic <code>HIGH</code> for one clock cycle. The requesting device can drive the irq_* signal to logic <code>LOW</code> in the clock cycle that follows the response, or keep it <code>HIGH</code> to make a new request.</p> <p>The timing diagram below is an example of a valid interrupt request:</p> <p> </p> Figure 3 - Interrupt request timing diagram <p>An interrupt request is accepted if:</p> <ul> <li> <p>the global interrupt enable bit is set (field mie in the mstatus CSR), and</p> </li> <li> <p>the corresponding interrupt type is enabled (fields meie, mtie and msie in the mie CSR).</p> </li> </ul> <p>The processor proceeds as follows when an interrupt request is accepted:</p> <ul> <li> <p>the execution of the current instruction is aborted.</p> </li> <li> <p>the memory address of the aborted instruction is saved in the mepc CSR.</p> </li> <li> <p>the program counter is set to the value of the mtvec CSR.</p> </li> <li> <p>the mcause CSR is set to a value encoding the type of the interrupt.</p> </li> <li> <p>the global interrupt enable bit mstatus.mie is set to logic <code>LOW</code>, disabling new interrupts.</p> </li> <li> <p>the prior interrupt enable bit mstatus.mpie is set to logic <code>HIGH</code>.</p> </li> <li> <p>the corresponding response signal (irq_*_response) is set to logic <code>HIGH</code> for one clock cycle.</p> </li> </ul> <p>The mtvec CSR is set by software to the address of an interrupt handler routine, so the core branches from normal execution and starts the execution of the interrupt handler.</p> <p>The mret instruction is used by software to return from the interrupt handler. When this instruction is executed the core proceeds as follows:</p> <ul> <li> <p>the program counter is set to the value of the mepc CSR.</p> </li> <li> <p>the global interrupt enable bit mstatus.mie receives the value saved in the mstatus.mpie bit.</p> </li> <li> <p>the prior interrupt enable bit mstatus.mpie is set to logic <code>LOW</code>. </p> </li> </ul> <p>The value in the mepc register is the address of the instruction aborted by the interrupt, so normal execution is resumed.</p>"},{"location":"core/#real-time-clock","title":"Real time clock","text":"<p>Systems that require a real time clock can connect the time CSR to an external clock device through the real_time_clock bus. By doing so, wall clock time can be obtained by reading the time CSR with the csrrw instruction.</p> <p>Systems that do not need a real time clock can hardwire this signal to <code>64'b0</code>, which causes reading the time CSR to return zero. In this case time lapses can still be measured by reading the cycle counter mcycle, as long as the clock signal is connected to a stable oscillating signal.</p> <p> </p>"},{"location":"get_started/","title":"Getting Started","text":""},{"location":"get_started/#introduction","title":"Introduction","text":"<p>This guide shows how to synthesize the SoC IP demo project for two Digilent development boards: Arty A7 and Cmod A7.</p> <p>The demo project is a Hello World application that makes the SoC IP send a \"Hello World!\" message to your computer via the board's UART interface. Its goal is to quickly introduce you to the SoC IP so that you can expand it and develop your own embedded applications.</p> <p>Looking for the demo project for other development boards?</p> <p>We are willing to help! Let us know which development board you would like the demo project ported to by opening a new issue on GitHub.</p>"},{"location":"get_started/#first-steps","title":"First steps","text":"<p>To follow this guide you'll need one of the following FPGA boards:</p> <ul> <li> <p>Digilent Arty A7</p> </li> <li> <p>Digilent Cmod A7</p> </li> </ul> <p>Also, make sure you have the following software installed on your computer:</p> <ul> <li> <p>AMD Xilinx Vivado</p> <p>The latest version of AMD Xilinx Vivado is available for download here.</p> <p>During installation, remember to include support for the Artix-7 device family and the cable drivers.</p> </li> <li> <p>PySerial</p> <p>PySerial is a Python package for communication over serial protocol. It can be installed by running:</p> <pre><code>python -m pip install pyserial\n</code></pre> </li> </ul>"},{"location":"get_started/#get-risc-v-steel","title":"Get RISC-V Steel","text":"<p>Clone RISC-V Steel repository from GitHub:</p> <pre><code>git clone https://github.com/riscv-steel/riscv-steel.git\n</code></pre>"},{"location":"get_started/#start-pyserial","title":"Start PySerial","text":"<p>Connect your Digilent board to your computer using a USB cable and start PySerial terminal by running:</p> <pre><code>python -m serial.tools.miniterm\n</code></pre> <p>A list of available serial ports will follow. Select the port your board is connected to and keep the terminal open for the next steps.</p> <p></p>"},{"location":"get_started/#program-the-fpga","title":"Program the FPGA","text":"<p>Open AMD Xilinx Vivado and follow the steps:</p> <ol> <li> <p>Click Run Tcl Script in the Tools menu.</p> </li> <li> <p>Select <code>hello_world_???.tcl</code> and click Ok. The <code>???</code> stands for your board name.</p> <p>This file is located at <code>demos/boards/???/</code> and it creates the demo project for your board in Vivado.</p> </li> <li> <p>Click on Generate Bitstream in the Flow menu.</p> </li> <li> <p>Click Open Hardware Manager in the Flow menu.</p> </li> <li> <p>Click Auto Connect in the Tools menu.</p> </li> <li> <p>Click Program Device in the Tools menu. A dialog box asking you to provide the bitstream will open.</p> </li> <li> <p>Search for <code>hello_world_???.bit</code>. Again, the <code>???</code> stands for your board name.</p> <p>This file is located at <code>demos/boards/???/hello_world_???/hello_world_???.runs/impl_1/</code>.</p> </li> <li> <p>Click on Program and wait for Vivado to finish programming the FPGA.</p> </li> </ol> <p>Now go back to PySerial terminal window. You should see the message below:</p> <p></p>"},{"location":"get_started/#next-steps","title":"Next steps","text":"<p>If you've reached this point, congratulations! You have a working instance of the SoC IP. You can now change it to create your own embedded applications.</p> <ul> <li> <p>Run your own software</p> <p>The SoC IP Software Guide contains instructions on how to write, compile, and run software applications for the SoC IP.</p> </li> <li> <p>Expand the design</p> <p>The SoC IP Documentation contains detailed information about its design so that you can expand it to create larger projects.</p> </li> </ul> <p> </p>"},{"location":"license/","title":"License","text":"<p>RISC-V Steel is free and open. It is distributed under the MIT License, reproduced below.</p> <p> <p>Copyright (c) 2020-2024 RISC-V Steel contributors</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p> <p></p>"},{"location":"soc/","title":"RISC-V Steel System-on-Chip","text":"Documentation"},{"location":"soc/#introduction","title":"Introduction","text":"<p>RISC-V Steel System-on-Chip expands the Processor Core IP by adding memory and UART modules to its design. It comes with a Software API that makes it easy to develop new RISC-V applications.</p> <p>This page contains information about the SoC IP hardware design. Check out the Software Guide for instructions on how to write, compile and run software for the SoC IP.</p>"},{"location":"soc/#design-overview","title":"Design overview","text":"<p>Figure 1 - RISC-V Steel SoC IP design overview</p> <p></p>"},{"location":"soc/#source-files","title":"Source files","text":"<p>Table 1 - RISC-V Steel SoC IP source files</p> Module name Source file Description rvsteel_soc <code>hardware//soc/rvsteel_soc.v</code> Top module of RISC-V Steel SoC IP rvsteel_core <code>hardware/core/rvsteel_core.v</code> RISC-V Steel Processor Core rvsteel_ram <code>hardware/ram/rvsteel_ram.v</code> RAM memory rvsteel_uart <code>hardware/uart/rvsteel_uart.v</code> UART rvsteel_bus <code>hardware/bus/rvsteel_bus.v</code> System Bus"},{"location":"soc/#io-signals","title":"I/O signals","text":"<p>Table 2 - RISC-V Steel SoC IP top module input and output signals</p> Pin name Direction Size Description clock Input 1 bit Clock input. reset Input 1 bit Reset (active-high). halt Input 1 bit Halts the processor core (active-high). uart_rx Input 1 bit UART receiver pin. Must be connected to the transmitter (<code>TX</code>) pin of another UART device. uart_tx Output 1 bit UART transmitter pin. Must be connected to the receiver (<code>RX</code>) pin of another UART device."},{"location":"soc/#memory-map","title":"Memory Map","text":"<p>In RISC-V systems, all devices share the processor address space and are mapped to an exclusive region in it (Memory Mapped I/O). </p> <p>The memory region assigned to each device of RISC-V Steel SoC IP is listed in the table below.</p> <p>Table 4 - Memory Map of RISC-V Steel SoC IP</p> Start address Final address Mapped device <code>0x00000000</code> <code>0x(MEMORY_SIZE-1)</code> RAM memory <code>0x(MEMORY_SIZE)</code> <code>0x7fffffff</code> - <code>0x80000000</code> <code>0x80000004</code> UART <code>0x80000005</code> <code>0xffffffff</code> -"},{"location":"soc/#configuration","title":"Configuration","text":"<p>Table 3 - Configuration parameters of RISC-V Steel SoC IP</p> Parameter name Default value Value type and description <code>BOOT_ADDRESS</code> <code>32'h00000000</code> 32-bit hexadecimal value. Memory address of the first instruction to be fetched and executed. <code>CLOCK_FREQUENCY</code> <code>50000000</code> Integer. Frequency (in hertz) of the clock input signal. <code>UART_BAUD_RATE</code> <code>9600</code> Integer. UART baud rate (in bauds per second). <code>MEMORY_SIZE</code> <code>8192</code> Integer. RAM memory size (in bytes). <code>MEMORY_INIT_FILE</code> <code>(empty string)</code> String. Path to a memory initialization file."},{"location":"soc/#instantiation-template","title":"Instantiation template","text":"<p>An instantiation template for RISC-V Steel SoC IP top module is provided below.</p> <pre><code>rvsteel_soc #(\n\n  // Configuration parameters. For more information read the 'Configuration'\n  // section of RISC-V Steel System-on-Chip Documentation\n\n  .BOOT_ADDRESS             (),  // Default value: 32'h00000000\n  .CLOCK_FREQUENCY          (),  // Default value: 50000000\n  .UART_BAUD_RATE           (),  // Default value: 9600\n  .MEMORY_SIZE              (),  // Default value: 8192\n  .MEMORY_INIT_FILE         ())  // Default value: Empty string (uninitialized)\n\n  rvsteel_soc_instance (\n\n  // I/O signals. For more information read the 'I/O signals'\n  // section of RISC-V Steel System-on-Chip Documentation\n\n  .clock                    (),  // Connect this pin to a clock source\n  .reset                    (),  // Connect this pin to a switch/button or hardwire it to 1'b0.\n  .halt                     (),  // Connect this pin to a switch/button or hardwire it to 1'b0.\n  .uart_rx                  (),  // Connect this pin to the TX pin of another UART device\n  .uart_tx                  ()   // Connect this pin to the RX pin of another UART device\n\n);\n</code></pre>"},{"location":"soc/#how-to-add-new-devices","title":"How to add new devices","text":"<p>You can integrate a new device into the SoC IP design by making simple changes to its top module. The following lines of <code>rvsteel_soc.v</code> contain the parameters you need to change:</p> <pre><code>  // System bus configuration\n\n  localparam NUM_DEVICES    = 2;\n  localparam D0_RAM         = 0;\n  localparam D1_UART        = 1;\n\n  wire  [NUM_DEVICES*32-1:0] device_start_address;     \n  wire  [NUM_DEVICES*32-1:0] device_region_size;\n\n  assign device_start_address [32*D0_RAM  +: 32]  = 32'h0000_0000;\n  assign device_region_size   [32*D0_RAM  +: 32]  = 8192;\n\n  assign device_start_address [32*D1_UART +: 32]  = 32'h8000_0000;\n  assign device_region_size   [32*D1_UART +: 32]  = 8;\n</code></pre> <p>The <code>NUM_DEVICES</code> parameter holds the total number of devices in the system. Each device is assigned an index (<code>D0_RAM</code> and <code>D1_UART</code>). To accomodate your new device you need to increase <code>NUM_DEVICES</code> and assign it the next index, <code>2</code>, like this:</p> <pre><code>  localparam NUM_DEVICES    = 3;\n  localparam D0_RAM         = 0;\n  localparam D1_UART        = 1;\n  localparam D2_NEW_DEVICE  = 2; // your new device\n</code></pre> <p>Next you have to assign your device a region in the processor's address space. You can assign it to any free region (see Memory Map). The region cannot overlap the address space of other devices and its size must be a power of 2. In the example below, the new device <code>D2_NEW_DEVICE</code> is assigned a 32KB region starting at <code>0x00008000</code>:</p> <pre><code>  assign device_start_address [32*D2_NEW_DEVICE +: 32]  = 32'h0000_8000;\n  assign device_region_size   [32*D2_NEW_DEVICE +: 32]  = 32768;\n</code></pre> <p>Finally, you have to instantiate the new device in the <code>rvsteel_soc</code> module and connect it to the system bus interface. The Processor Core IP will issue read and write requests to your device as described in the I/O Operations section of its Documentation. A template for instantiating and connecting the new device to the system bus is provided below:</p> <pre><code>  // Instantiate the new device in the rvsteel_soc.v module like this:\n\n  new_device\n  new_device_instance (\n\n    // I/O interface of the new device\n\n    .new_device_rw_address      (device_rw_address                        ),\n    .new_device_read_data       (device_read_data[32*D2_NEW_DEVICE +: 32] ),\n    .new_device_read_request    (device_read_request[D2_NEW_DEVICE]       ),\n    .new_device_read_response   (device_read_response[D2_NEW_DEVICE]      ),\n    .new_device_write_data      (device_write_data                        ),\n    .new_device_write_strobe    (device_write_strobe                      ),\n    .new_device_write_request   (device_write_request[D2_NEW_DEVICE]      ),\n    .new_device_write_response  (device_write_response[D2_NEW_DEVICE]     )\n\n  );\n</code></pre> <p> </p>"},{"location":"software_guide/","title":"RISC-V Steel System-on-Chip","text":"Software Guide"},{"location":"software_guide/#first-steps","title":"First steps","text":"<p>To compile, assemble and link programs for RISC-V machines you need the RISC-V GNU Toolchain. The steps below show how to install and configure the toolchain for use with RISC-V Steel.</p> 1. Get the source files <pre><code>git clone https://github.com/riscv/riscv-gnu-toolchain\n</code></pre> 2. Install dependencies UbuntuFedora/CentOS/RHEL OSArch LinuxOS X <pre><code>sudo apt-get install autoconf automake autotools-dev curl python3 python3-pip libmpc-dev libmpfr-dev libgmp-dev gawk build-essential bison flex texinfo gperf libtool patchutils bc zlib1g-dev libexpat-dev ninja-build git cmake libglib2.0-dev\n</code></pre> <pre><code>sudo yum install autoconf automake python3 libmpc-devel mpfr-devel gmp-devel gawk  bison flex texinfo patchutils gcc gcc-c++ zlib-devel expat-devel\n</code></pre> <pre><code>sudo pacman -Syyu autoconf automake curl python3 libmpc mpfr gmp gawk base-devel bison flex texinfo gperf libtool patchutils bc zlib expat\n</code></pre> <pre><code>brew install python3 gawk gnu-sed gmp mpfr libmpc isl zlib expat texinfo flock\n</code></pre> 3. Configure it for RISC-V Steel <pre><code>cd riscv-gnu-toolchain\n./configure --with-arch=rv32i --with-abi=ilp32 --prefix=/opt/riscv\n</code></pre> 4. Compile and install <pre><code>make -j $(nproc)\n</code></pre>"},{"location":"software_guide/#make-a-copy-of-the-template-project","title":"Make a copy of the template project","text":"<p>Once you have installed the RISC-V GNU Toolchain you can start a new application. The easiest way to start is making a copy of the template project (located at <code>software/template_project/</code>). The template project comes with a Makefile to help you automate the tasks of compiling the software and generating a memory initialization file for the SoC IP.</p>"},{"location":"software_guide/#configure-your-project","title":"Configure your project","text":"<p>You configure the template project by editing the Makefile in it. The Makefile starts with the definition of the four variables you need to set for your project. The expected value for these variables are described in the table below.</p> Variable Description <code>PROGRAM_NAME</code> The name of the ELF executable to be generated. Ex: myapp. <code>MEMORY_SIZE</code> The size you set for the RAM memory of the SoC IP (the same value you provided for the <code>MEMORY_SIZE</code> parameter when instantiating the <code>rvsteel_soc</code> module). <code>RVSTEEL_API_DIR</code> Path to the directory containing the source files of the Software API. <code>RISCV_PREFIX</code> Path to the RISC-V GNU Toolchain binaries in your machine + RISC-V binaries prefix."},{"location":"software_guide/#write-your-application","title":"Write your application","text":"<p>The template project comes with a <code>main.c</code> file containing a Hello World example. You can edit this file, rename it or delete it.</p> <p>You can add as many source files to the project as you want. The Makefile was written so that all <code>*.c</code> source files you add to the project get automatically compiled when you run <code>make</code>.</p> <p>The SoC IP has an API with functions you can call in your software to configure and control the devices in it. The Software API page contains the documentation for the available API calls.</p>"},{"location":"software_guide/#compile-and-generate-the-memory-init-file","title":"Compile and generate the memory init file","text":"<p>Run <code>make</code> to build your application and generate the memory initialization file. A successfull build output is similar to this:</p> <pre><code>Generated files:\n-- ELF executable   : build/my_app.elf\n-- Disassembly      : build/my_app.objdump\n-- Memory init file : build/my_app.hex\n\nThe memory size is set to 8192 bytes.\n</code></pre> <p>The <code>.hex</code> file can now be used to initialize RISC-V Steel SoC IP memory and run the application.</p>"},{"location":"software_guide/#run-the-application","title":"Run the application","text":"<p>When you synthesize the SoC IP for your FPGA, the data to be loaded into the SoC IP memory gets embedded in the FPGA bitstream. Every time you power on your FPGA the memory gets initialized and your program runs immediately afterwards.</p> <p>You define the initial content of the SoC IP memory through the <code>MEMORY_INIT_FILE</code> parameter. This parameter expects a string with the path to the memory initialization file you generated in the steps above.</p> <pre><code>// This example shows an instantiation of the SoC IP top module \n// configured to load the contents of a file named `hello_world.hex`\n\n// The initial contents of the SoC IP memory gets embedded in the\n// FPGA bitstream when the module is synthesized\n\nrvsteel_soc                  #(\n    .CLOCK_FREQUENCY          (50000000           ),\n    .UART_BAUD_RATE           (9600               ),\n    .MEMORY_SIZE              (8192               ),\n    .MEMORY_INIT_FILE         (\"hello_world.hex\"  ),\n    .BOOT_ADDRESS             (32'h00000000       ))\nrvsteel_soc_instance          ( \n    .clock                    (clock_50mhz        ),\n    .reset                    (reset              ),\n    .uart_rx                  (uart_rx            ),\n    .uart_tx                  (uart_tx            ));\n</code></pre> <p> </p>"}]}